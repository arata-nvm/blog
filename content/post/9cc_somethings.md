---
title: "9cc メモ"
date: 2020-04-04T14:56:53+09:00
draft: true
---

## まえがき

9cc を写経した時のメモ。
悲しいことに、メモの大部分が消失していた。
許すまじ。

## 56e94442ae8844688d5390851e5b29ba0c946e2f

Makefile で `*.c` のタスクは標準で用意されているらしい。

アセンブリの数字の部分を変えるだけ。

## 916237396164ae25557b62bf0d1ca9d9cf8c2070

加減算ができるようになった。

`strtol`は数字の後までポインタを進めてくれる。

## 42adde9b5e0ed09c0d76bb84da38d136be8390c1

トークナイザを導入して空白を処理できるようになった。

トークンを保持する配列はサイズをとりあえず 100 で宣言している。

トークンの`enum`が 256 から始まるのは文字との衝突を避けるためっぽい。

## 2f62e5267a1c2874dcfa674cf8654e0cb3f189d6

再帰下降構文解析を実装した。

レジスタを順番に使用しているが、開放処理がないためまだ任意の加減算のみの式を評価できない。

## dca0fdb71df98d8500170ff8178eaac0c8f9edaa

IR を導入した。

レジスタの開放処理が実装された。


`noreturn`とは
可変長引数

---

## 42e403e3de0c6457bc11ab14c55a9dad27ed82be

数字をパースしていたところで Ident をパースしている。

式をパースした後、'='が存在したら代入としてパースしている。代入が式として扱われるのはここに理由がありそう。

## 42e403e3de0c6457bc11ab14c55a9dad27ed82be

左辺値が登場し、変数への代入が可能になった。

変数は Map で保持している。 bpoff で次に確保する変数用のメモリの位置(いわゆる`[eax+8]` の `8` の部分の数字)を保持する。変数の宣言時にはbpoffを記録しておき参照時に使用する。ただし、ポインタの計算(`eax+8`の計算)はレジスタを用いて行う。basereg はおそらくまだ使っていない。

関数の前後で恒例のスタックの操作がでできた。

最後にラベルを作ってそこにジャンプしている理由がわからない。

## 1180f8627baf02be61338bcc3c7342525af3736b

`add` で右辺が即値のとき、レジスタを経由せず直接即値で計算するように。

```asm
r10+2 を計算

mov r11, 2
add r10, r11
↓
add r10, 2
```

malloc と calloc の違いはなんなのだろうか。

## 167c37e3516aa50ad2356268e9b560701b8b8769

式中の`()`に対応した。

`(`を見つけたとき、そこから式をパースして子のノードにするだけ。

## aba37adee785f3ba01d659e085e80c95292da90a

1180f8627baf02be61338bcc3c7342525af3736b の処理を整理した。

新たに IR を追加しただけ。

## 5cad7651f8a1bb9979d8c190ea586d350b3b488a

then のみの if を追加した。

構造体`IRInfo`が追加された。アセンブリの命令の形には大体のパターンがあるのでそのあたりの処理を統一するのが目的？

C言語では数値なども条件式として使用できるため、`0であるか`で分岐する

最後にある`.Lend`がここで使われた。分岐後の処理をここに飛ばしていた。

IR の enum も TK_* と同様に 256 から始めるように。

## be12da2aa402dac74ad20c84393e84feb3c821ed

if に else を追加した。

jmp 命令を追加し、 then の部分をジャンプすることで実現する。

jmp命令が連続し、使用されない命令があっても良いらしい。
```asm
  je .L0
  (else)
  jmp .Lend <-
  jmp .L1   <-
.L0:
  (then)
  jmp .Lend
.L1:
.Lend:
  (...)
```

## 8cd93cfc2cedfd6eb47c6c15a84933e0ca66d8d8

StringBuilder を実装した。

サイズを増やすときは2倍とし、realloc の回数を減らしている。

## 96a5fb2ed4b5f73e85b9660b6255a591bf3a23dc

関数の呼び出しを実装した。

ir.c:54 のところで`{}`で囲まなければいけない理由がわからなかった。囲まないとエラーになった。

6つ以上の引数には対応していない。

コード生成で `push` を7つ並べているのはなにか意味がある?

## c7933acab4e410aa0c0c7a38358092208ace822d

関数の宣言を実装した。

## cb98af07a69bfdd377835951e67d4323db4dc6dc

引数のある関数を実装した。

引数はレジスタを使用して渡し、メモリに保持する。

## 0bb7d0ee82ad3c2dd86c0793967f3c3d5723b5dd

`clang-format`を使用してコードをフォーマットした。

clang標準のフォーマットが決められているのだろうか。

## e5f5f5a872471516b4f81a36c23081d2ddb52d8f

論理演算子`&&``||`の実装。

`&&`の方を先にまとめ、次に`||`でまとめることで正しく処理できる。

`a && b`の処理
1. 脱出用のラベルを生成
2. aがfalseならラベルに飛ぶ
3. bがfalseならラベルに飛ぶ
4. bがtrueなら1(true)を返して終了

`a || b`の処理
1. 脱出用のラベル1,2を生成
2. aがfalseならラベル1に飛ぶ
3. aがtrueならラベル2に飛ぶ
3. bがfalseならラベル2に飛ぶ

グローバル変数の`static`の有無で変わる挙動は？

通常一文字単位で処理される記号を複数組み合わせたトークン(`||``&&`など)はマップに保持し、`strncmp`で処理する。

## 9108b18ac463ddc290dc0446ed04dec31532a6e9

演算子`<``>`の実装。

`cmp`命令の後`setl`命令でレジスタに比較結果を代入する。
`setl`命令は左辺値が右辺値より小さいときレジスタに1を代入する。
バイトレジスタを要求するので、`movzb`命令で32bitレジスタに値を代入する。

IRとしては`<`のみを実装し、`>`は左辺と右辺を入れ替えることで対応する。

## 6168e9c38414f8877fcc23242d7c5f97f2925002

変数関連の処理を別ファイルにまとめた。
